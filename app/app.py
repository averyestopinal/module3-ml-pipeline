import os
import yaml
import gradio as gr
import pandas as pd
import requests
import numpy as np

API_URL = "http://127.0.0.1:8000/predict_named"

# point to config.yaml so server uses same paths as scripts
CONFIG_PATH = os.path.join(os.path.dirname(__file__), "..", "config.yaml")
if os.path.exists(CONFIG_PATH):
    with open(CONFIG_PATH, "r") as f:
        cfg = yaml.safe_load(f)
else:
    cfg = {}

# read artifacts paths from config 
PREPROCESSOR_PATH = cfg.get("artifacts", {}).get("preprocessor", "artifacts/preprocessor.joblib")
MODEL_PATH = cfg.get("artifacts", {}).get("model", "artifacts/model.joblib")
EXPECTED_COLS = cfg.get("data", {}).get("input_columns", None)
if EXPECTED_COLS is None:
    # is not present EXPECTED_COLS becomes empty
    EXPECTED_COLS = []

# Create list of columns that will be in the UI, these are the most easily known by a user of our app
ENTRY_COLS = [
    "Company",
    "Altitude",
    "Region",
    "Producer",
    "Harvest.Year",
    "Variety",
    "Expiration"
]

# Narrowing EXPECTED_COLS to just those found in ENTRY_COLS
UI_COLS = [col for col in EXPECTED_COLS if col in ENTRY_COLS]
# The above snippet was generated by chatGPT 5.1 at 1:40p on 11/22/25.


# All column entries for interface, made all empty at first for user to enter values into
empty_df = pd.DataFrame([{col: "" for col in UI_COLS}])
# The above snippet was generated by chatGPT 5.1 at 2:33p on 11/21/25 and modified to traverse the correct list.


def cup_points_estimator(known_values_input):
    """
    Accepts the Gradio Dataframe value (likely a pandas.DataFrame, list-of-lists, or list-of-dicts).
    Tries to call the prediction API (POST /predict_named -> {"rows":[{...}]}) and return the first prediction.
    If the API request fails, falls back to a simple heuristic:
      - convert any numeric-looking columns to numbers and return the row-wise mean (or 0 if no numeric data).
    """
    # helper: convert various Gradio input types into a pandas DataFrame with UI_COLS as columns
    try:
        # If it's already a DataFrame
        if isinstance(known_values_input, pd.DataFrame):
            df = known_values_input.copy()
        # If Gradio returned a list of dicts (records)
        elif isinstance(known_values_input, list) and known_values_input and isinstance(known_values_input[0], dict):
            df = pd.DataFrame(known_values_input)
        # If it's a list of lists (rows)
        elif isinstance(known_values_input, list):
            try:
                df = pd.DataFrame(known_values_input, columns=UI_COLS)
            except Exception:
                # fallback: construct DataFrame and trim/pad columns
                df = pd.DataFrame(known_values_input)
        # Otherwise try to coerce
        else:
            df = pd.DataFrame([known_values_input])
    except Exception:
        # If all conversions fail, return a safe default
        return 0.0

    # Ensure DataFrame contains the UI_COLS (in the same order). Fill missing cols with empty strings.
    for col in UI_COLS:
        if col not in df.columns:
            df[col] = ""
    df = df[UI_COLS]

    # Prepare payload: convert NaN -> None so JSON is clean
    payload_rows = df.where(pd.notnull(df), None).to_dict(orient="records")
    payload = {"rows": payload_rows}

    # Try calling the API; short timeout to keep UI responsive
    try:
        resp = requests.post(API_URL, json=payload, timeout=3.0)
        resp.raise_for_status()
        data = resp.json()
        # Expect {"predictions": [...]} - return first prediction if present
        preds = data.get("predictions")
        if preds and isinstance(preds, (list, tuple)) and len(preds) > 0:
            # cast to float for Gradio Number output
            return float(preds[0])
    except Exception:
        # any failure falls through to fallback heuristic below
        pass

    # ----- Fallback heuristic: numeric mean of row values -----
    # Try to coerce columns to numeric where possible; non-numeric columns become NaN
    numeric_df = df.apply(lambda col: pd.to_numeric(col, errors="coerce"))
    # If there are numeric columns, return the mean across numeric columns for the first row
    if numeric_df.shape[1] > 0 and numeric_df.notna().any(axis=1).any():
        row0 = numeric_df.iloc[0]
        valid = row0.dropna()
        if len(valid) > 0:
            return float(valid.mean())

    # If no numeric info available, return a conservative default (e.g., 0.0)
    return 0.0


# Gradio interface that takes interie into table and outputs integer using cup_points_estimator
demo = gr.Interface(    
    fn=cup_points_estimator,

    # Citation: OpenAI. (2025). ChatGPT (Version 5.1) [Large language model]. https://chat.openai.com 
    #   Conversation with ChatGPT on February 11, 2025, used to generate the Gradio app code for a coffee cup-points estimator.
    # This snippet was susequently modified to have the correct headers
    inputs=gr.Dataframe(
        headers=UI_COLS,
        value=empty_df,
        row_count=1,
        col_count=len(UI_COLS),
        interactive=True,
        label="Enter Known Values"
    ),
    outputs=gr.Number(label="Estimated Coffee Cup Points (A score above 80 is generally considered as a speciality coffee)"),
    # ----------------END CITED BLOCK-------------------------

    title="Coffee Cup Points Estimator",
    description="Enter known values for coffee into table. The estimated Cop Score from a Q Grader trained by the Coffee Quality Institute will be predicted."
)

# Launch for local testing
demo.launch()
